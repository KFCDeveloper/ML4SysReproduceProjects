#!/usr/bin/env perl
#
# opp_msgc: translates MSG files into C++ code.
#

$MSGC_VERSION = "4.5";
$MSGC_VERSION_HEX = "0x0405";

sub processFile($);
sub quote($);
sub unquote($);
sub canonicalizeQName($$);
sub prefixWithNamespace($$);
sub lookupExistingClassName($$);
sub lookupExistingEnumName($$);


#
# If no args, print usage
#
$Usage = 'opp_msgc - part of OMNeT++. (c) 2002-2013 Andras Varga
Translates .msg files into C++

Usage: opp_msgc [-s <cc-file-suffix>] [-t <h-file-suffix>]
                [-I <dir> -I ...] [-h] [-Xnc] [-Xnd]
                <msgfilenamepatterns-and-directories>
  -v          verbose
  -I <dir>    add directory to include path
  -s <suffix> output C++ file suffix (defaults to: _m.cc)
  -t <suffix> output C++ header file suffix (defaults to: _m.h)
  -P <symbol> add dllexport/dllimport symbol to class declarations; if symbol
              name ends in _API, boilerplate code to conditionally define
              it as OPP_DLLEXPORT/OPP_DLLIMPORT is also generated
  -h          output in current directory
  -A          no timestamp check, always overwrite output files.
              (by default, opp_msgc only overwrites output files if they
              appear to be out-of-date, according to file time/date)
  -Xnc        do not generate the classes, only object descriptions
  -Xnd        do not generate object descriptions
  -Xns        do not generate setters in object descriptions
';

if ($#ARGV == -1)
{
    print $Usage;
    exit(0);
}

#
#  Parse the command line for options and files.
#
@filenames = ();
$here = 0;
$checktimestamps = 1;
$ccsuffix = '_m.cc';
$hsuffix = '_m.h';
$exportdef = '';
$generate_classes = 1;
$generate_descriptors = 1;
$generate_setters_in_descriptors = 1;
$verbose = 0;
while (@ARGV)
{
    $arg = shift @ARGV;

    if ($arg eq "-s")
    {
        $ccsuffix = shift @ARGV;
    }
    elsif ($arg eq "-t")
    {
        $hsuffix = shift @ARGV;
    }
    elsif ($arg eq "-I")
    {
        # import not supported: just ignore -I <dir> for now
        shift @ARGV;
    }
    elsif ($arg =~ /^-I/)
    {
        # import not supported: just ignore -I<dir> for now
    }
    elsif ($arg eq "-P")
    {
        $exportdef = shift @ARGV;
        $exportdef =~ s/[ \t]//g;
        $exportdef .= " ";
    }
    elsif ($arg =~ /^-P/)
    {
        $exportdef = $arg;
        $exportdef =~ s/^-P//;
        $exportdef =~ s/[ \t]//g;
        $exportdef .= " ";
    }
    elsif ($arg eq "-h")
    {
        $here = 1;
    }
    elsif ($arg eq "-A")
    {
        $checktimestamps = 0;
    }
    elsif ($arg eq "-v")
    {
        $verbose = 1;
    }
    elsif ($arg eq "-Xnc")
    {
        $generate_classes = 0;
    }
    elsif ($arg eq "-Xnd")
    {
        $generate_descriptors = 0;
    }
    elsif ($arg eq "-Xns")
    {
        $generate_setters_in_descriptors = 0;
    }
    elsif (!($arg =~ /^-/))
    {
        #FIXME implement end-of-options ('--')
        if (-d $arg) {
            $arg .= '/*.msg';
        }
        # only glob if contains "*" or "?"
        if ($arg =~ /\*/ || $arg =~ /\?/) {
            foreach my $i (glob($arg)) {
                push(@filenames, $i);
            }
        }
        elsif (-f $arg) {
            push(@filenames, $arg);
        }
        else {
            die "*** Error: no such file or directory: $arg\n";
        }
    }
    else
    {
        die "*** Error: unrecognized argument: $arg\n";
    }
}

$ret = 0;
foreach my $ii (@filenames)
{
    processFile($ii);
}

exit $ret;

#
# Processes a file. Note: information gets passed to other procs
# (prepareForCodeGeneration, etc) in global variables
#
sub processFile($)
{
    $filename = shift;
    print "processing $filename...\n" if $verbose;

    #
    # parse file
    #
    $filename =~ /\.[^\\\/]*$/;
    $filename =~ s|\\|/|g;
    $hfile = $filename;
    $hfile =~ s|\.[^.]*$|$hsuffix|;
    if ($here)
    {
        $hfile =~ s|^.*/||;
    }
    $hfilenamewithoutdir = $hfile;
    $hfilenamewithoutdir =~ s|^.*/||;
    $ccfile = $filename;
    $ccfile =~ s|\.[^.]*$|$ccsuffix|;
    if ($here)
    {
        $ccfile =~ s|^.*/||;
    }

    if ($checktimestamps)
    {
        $msgfiledate = (stat($filename))[9];
        $ccfiledate = (stat($ccfile))[9];
        $hfiledate = (stat($hfile))[9];
        if ($msgfiledate<$ccfiledate && $msgfiledate<$hfiledate) {
            print "output files up to date, skipping $filename\n" if $verbose;
            return;
        }
    }

    $obsoletesyntax = 0;

    $msg = "";
    open(IN,$filename) || die "$filename: Error: cannot open input file $filename";
    while (<IN>)
    {
        s|\r||;
        s|//.*$||;
        $msg .= $_;
    }
    close(IN);

    # pre-register some OMNeT++ classes so that one doesn't need to announce them
    #
    # @classes contains fully qualified names (ie with namespace); keys to the other hashes are fully qualified as well
    #
    # note: $classtype values:
    #  'cownedobject' ==> subclasses from cOwnedObject
    #  'cnamedobject' ==> subclasses from cNamedObject but NOT from cOwnedObject
    #  'cobject'      ==> subclasses from cObject but NOT from cNamedObject
    #  'foreign'      ==> non-cObject class (classes announced as "class noncobject" or "extends void")
    #  'struct'       ==> struct (no member functions)
    #
    @classes = ('cObject', 'cNamedObject', 'cOwnedObject', 'cMessage', 'cPacket');
    $classtype{'cObject'} = 'cobject';
    $classtype{'cNamedObject'} = 'cnamedobject';
    $classtype{'cOwnedObject'} = 'cownedobject';
    $classtype{'cMessage'} = 'cownedobject';
    $classtype{'cPacket'} = 'cownedobject';

    @enums = ();

    # some regex patterns
    $RESERVED_WORDS = 'namespace|cplusplus|struct|message|packet|class|noncobject|'
        . 'enum|extends|abstract|readonly|properties|fields|bool|char|short|'
        . 'int|long|double|unsigned|string|true|false'
        . 'float|int8|int16|int32|int64|uint8|uint16|uint32|uint64'
        . '|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t'
        . 'for|while|if|else|do|enum|class|struct|typedef|public|private'
        . '|protected|auto|register|sizeof|void|new|delete|explicit|static'
        . '|extern|return|try|catch';

    $PRIMITIVE_TYPES = 'bool|float|double|simtime_t|string|((unsigned )?(char|short|int|long))|(u?int(8|16|32|64)(_t)?)';

    $NAME = '([A-Za-z_][A-Za-z0-9_]*)';  # 1 group
    $QNAME = "((::)?($NAME\:\:)*$NAME)"; # 5 groups

    $CPLUSPLUS_BLOCK = '\bcplusplus\s+\{\{(.*?)\}\};?';  # 1 group (contains body)
    $NAMESPACE_DECL = '\bnamespace\s+([A-Za-z0-9_:]+)\s*;'; # 1 group (contains name)

    # encode cplusplus blocks in a copy of msg, so that we don't accidentally match namespace keywords in them
    $tmp = $msg;
    %cppblocks = {};
    $counter = 0;
    $tmp =~ s/($CPLUSPLUS_BLOCK)/$cppblocks{++$counter}=$1;"cplusplus-$counter;"/gse;

    # split file to parts above and below the namespace declaration.
    # This is important because the namespace should only apply to cplusplus{{ }}
    # blocks after the namespace declaration.
    if ($tmp =~ /(.*)$NAMESPACE_DECL(.*)/s ) {
        $cpp_above_namespace = $1;
        $cpp_below_namespace = $3;
    } else {
        $cpp_above_namespace = $tmp;
        $cpp_below_namespace = '';
    }

    # restore cplusplus blocks in $cpp_above_namespace and $cpp_below_namespace
    $cpp_above_namespace =~ s/cplusplus-(\d+);/$cppblocks{$1}/gse;
    $cpp_below_namespace =~ s/cplusplus-(\d+);/$cppblocks{$1}/gse;

    $msg =~ s/$CPLUSPLUS_BLOCK//sg; # cplusplus blocks not needed in $msg any more, remove them

    # parse namespace decl
    # note: we remove the decl from the source, and mark its place with a '<namespace>' marker string
    $namespacename = "";
    while ($msg =~ s/$NAMESPACE_DECL/<namespace>/s)
    {
        if ($namespacename ne "") {
            print "$filename: Error: multiple namespace declarations\n"; $ret=1;
        }

        $namespacename = $1;

        if (!($namespacename =~ /^$QNAME$/)) {
            print "$filename: Error: wrong syntax in namespace name '$namespacename'\n"; $ret=1;
        }

        $namespacename =~ s/^:://;
    }

    # parse imports
    while ($msg =~ s/import\s+(".*?");//s)
    {
        print "$filename: Error: imports are not supported (yet)\n"; $ret=1;
    }

    # parse type announcements
    while ($msg =~ s/(struct|class|class\s+noncobject|class\s+cpolymorphic|message|packet)\s+$QNAME(\s+extends\s+$QNAME)?\s*;/<class>/s)
    {
        my $type0 = $1;
        my $class = $2;
        my $baseclass = $8;

        my $precedesnamespacedecl = ($msg =~ /<class>.*<namespace>/s);
        $msg =~ s/<class>//s; # remove the marker inserted above

        my $classqname = canonicalizeQName($precedesnamespacedecl ? "" : $namespacename, $class);

        if ($type0 eq 'struct') {
            $type = 'struct';
        } elsif ($type0 eq 'message' || $type0 eq 'packet') {
            $type = 'cownedobject';
        } elsif ($type0 eq 'class') {
            if ($baseclass eq '') {
                $type = 'cownedobject';
            } elsif ($baseclass eq 'void') {
                $type = 'foreign';
            } else {
                my @found = lookupExistingClassName($namespacename, $baseclass);
                if (@found == 1) {
                    $type = $classtype{$found[0]};
                } elsif (@found == 0) {
                    print "$filename: Error: '$class': unknown ancestor class '$baseclass'\n"; $ret=1;
                    $type = 'cobject';
                } else {
                    print "$filename: Error: '$class': ambiguous ancestor class '$baseclass'; possibilities: " .join(', ',@found)."\n"; $ret=1;
                    $type = $classtype{$found[0]};
                }
            }
        } elsif ($type0 =~ /class\s+noncobject/) {
            $type = 'foreign';
            if ($baseclass) {
                print "$filename: Error: '$class': the keywords noncobject and extends cannot be used together\n"; $ret=1;
            }
        } elsif ($type0 =~ /class\s+cpolymorphic/) {
            $type = 'cobject';
            if ($baseclass) {
                 print "$filename: Error: '$class': the keywords cpolymorphic and extends cannot be used together\n"; $ret=1;
            }
        } else {
            die 'invalid type';
        }

        if ($class =~ /^($RESERVED_WORDS)$/) {
            print "$filename: Error: type name '$class' is a reserved word\n"; $ret=1;
        }
        if (grep(/^\Q$classqname\E$/,@classes)) {
            if ($classtype{$classqname} ne $type) {
                print "$filename: Error: different declarations for '$class' are inconsistent\n"; $ret=1;
            }
        } else {
            #print "DBG: classtype{$type0 $class $baseclass} = $type\n";
            $classtype{$classqname} = $type;
            push(@classes, $classqname);
        }
    }

    # produce header guard
    $hdef = $hfilenamewithoutdir;
    $hdef =~ s|^.*/||;
    $hdef =~ s|\.[^.]*$|_H_|;
    $hdef = '_'.$hdef;
    $hdef = '_'.$namespacename.$hdef if $namespacename ne "";
    $hdef =~ tr/[a-z]/[A-Z]/;
    $hdef =~ s/[^a-zA-Z0-9]/_/g;

    # generate
    open(H,">$hfile") || die "$filename: Error: cannot open output file $hfile";
    open(CC,">$ccfile") || die "$filename: Error: cannot open output file $ccfile";

    print H "//\n// Generated file, do not edit! Created by opp_msgc $MSGC_VERSION from $filename.\n//\n\n";
    print H "#ifndef $hdef\n";
    print H "#define $hdef\n\n";
    print H "#include <omnetpp.h>\n";
    print H "\n";
    print H "// opp_msgc version check\n";
    print H "#define MSGC_VERSION $MSGC_VERSION_HEX\n";
    print H "#if (MSGC_VERSION!=OMNETPP_VERSION)\n";
    print H "#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.\n";
    print H "#endif\n";
    print H "\n";

    if ($exportdef =~ /^(.*)_API *$/) {
        # generate boilerplate code for dll export
        my $exportbase = $1;
        print H "// dll export symbol\n";
        print H "#ifndef $exportdef\n";
        print H "#  if defined(${exportbase}_EXPORT)\n";
        print H "#    define $exportdef OPP_DLLEXPORT\n";
        print H "#  elif defined(${exportbase}_IMPORT)\n";
        print H "#    define $exportdef OPP_DLLIMPORT\n";
        print H "#  else\n";
        print H "#    define $exportdef\n";
        print H "#  endif\n";
        print H "#endif\n";
        print H "\n";
    }

    print CC "//\n// Generated file, do not edit! Created by opp_msgc $MSGC_VERSION from $filename.\n//\n\n";
    print CC "// Disable warnings about unused variables, empty switch stmts, etc:\n";
    print CC "#ifdef _MSC_VER\n";
    print CC "#  pragma warning(disable:4101)\n";
    print CC "#  pragma warning(disable:4065)\n";
    print CC "#endif\n\n";

    print CC "#include <iostream>\n";
    print CC "#include <sstream>\n";
    print CC "#include \"$hfilenamewithoutdir\"\n\n";

    print CC "USING_NAMESPACE\n\n";

    if ($generate_classes)
    {
        print CC "\n";
        print CC "// Another default rule (prevents compiler from choosing base class' doPacking())\n";
        print CC "template<typename T>\n";
        print CC "void doPacking(cCommBuffer *, T& t) {\n";
        print CC "    throw cRuntimeError(\"Parsim error: no doPacking() function for type %s or its base class (check .msg and _m.cc/h files!)\",opp_typename(typeid(t)));\n";
        print CC "}\n\n";
        print CC "template<typename T>\n";
        print CC "void doUnpacking(cCommBuffer *, T& t) {\n";
        print CC "    throw cRuntimeError(\"Parsim error: no doUnpacking() function for type %s or its base class (check .msg and _m.cc/h files!)\",opp_typename(typeid(t)));\n";
        print CC "}\n";
        print CC "\n";
    }
    print CC "\n\n";

    # generate cplusplus {{...}} blocks that are above the namespace declaration
    while ($cpp_above_namespace =~ s/$CPLUSPLUS_BLOCK//s)
    {
        my $block = $1;
        $block =~ s/^\s*(.*?)\s*$/$1/s; # trim
        print H "// cplusplus {{\n";
        print H "$block\n";
        print H "// }}\n\n";
    }
    print H "\n";

    foreach my $i (split("::", $namespacename)) {
        if ($i =~ /^($RESERVED_WORDS)$/) {
            print "$filename: Error: namespace name '$i' is a reserved word\n"; $ret=1;
        }
        print H "namespace $i {\n";
        print CC "namespace $i {\n";
    }
    print H "\n";
    print CC "\n";

    print CC "// Template rule for outputting std::vector<T> types\n";
    print CC "template<typename T, typename A>\n";
    print CC "inline std::ostream& operator<<(std::ostream& out, const std::vector<T,A>& vec)\n";
    print CC "{\n";
    print CC "    out.put('{');\n";
    print CC "    for(typename std::vector<T,A>::const_iterator it = vec.begin(); it != vec.end(); ++it)\n";
    print CC "    {\n";
    print CC "        if (it != vec.begin()) {\n";
    print CC "            out.put(','); out.put(' ');\n";
    print CC "        }\n";
    print CC "        out << *it;\n";
    print CC "    }\n";
    print CC "    out.put('}');\n";
    print CC "    \n";
    print CC "    char buf[32];\n";
    print CC "    sprintf(buf, \" (size=%u)\", (unsigned int)vec.size());\n";
    print CC "    out.write(buf, strlen(buf));\n";
    print CC "    return out;\n";
    print CC "}\n";
    print CC "\n";

    print CC "// Template rule which fires if a struct or class doesn't have operator<<\n";
    print CC "template<typename T>\n";
    print CC "inline std::ostream& operator<<(std::ostream& out,const T&) {return out;}\n";
    print CC "\n";

    # cplusplus {{...}} blocks below the namespace declaration
    while ($cpp_below_namespace =~ s/$CPLUSPLUS_BLOCK//s)
    {
        my $block = $1;
        $block =~ s/^\s*(.*?)\s*$/$1/s; # trim
        print H "// cplusplus {{\n";
        print H "$block\n";
        print H "// }}\n\n";
    }

    # parse enum announcements
    while ($msg =~ s/enum\s+$QNAME\s*;/<enum>/s)
    {
        $enumname = $1;

        my $precedesnamespacedecl = ($msg =~ /<enum>.*<namespace>/s);
        $msg =~ s/<enum>//s;  # remove the marker inserted above

        $enumqname = canonicalizeQName($precedesnamespacedecl ? "" : $namespacename, $enumname);

        if ($enumname =~ /^($RESERVED_WORDS)$/) {
            print "$filename: Error: enum name '$enumname' is a reserved word\n"; $ret=1;
        }

        if (grep(/^\Q$enumqname\E$/,@classes)) {
            print "$filename: Error: inconsistent declarations for '$enumname'\n"; $ret=1;
        } else {
            push(@enums, $enumqname);
        }
    }

    # parse enums
    while ($msg =~ s/enum\s+([A-Za-z0-9_: \t]+?)\s*{(.*?)};?/<enum>/s)
    {
        $source = $&;
        $enumhdr = $1;
        $fields = $2;

        if ($enumhdr =~ /^$NAME\s+extends\s+$QNAME$/s)
        {
            $enumname = "???";
            $baseenum = '';
            print "$filename: Error: '$enumhdr': enum inheritance is not supported\n"; $ret=1;
        }
        elsif ($enumhdr =~ /^$NAME$/s)
        {
            $enumname = $enumhdr;
            $baseenum = '';
        }
        else
        {
            $enumhdr =~ s/\s+/ /sg;
            print "$filename: Error: invalid enum declaration syntax '$enumhdr'\n"; $ret=1;
            $enumname = "???";
            $baseenum = '';
        }

        if ($enumname =~ /^($RESERVED_WORDS)$/) {
            print "$filename: Error: enum name '$enumname' is a reserved word\n"; $ret=1;
        }

        if ($msg =~ /<enum>.*<namespace>/s) {
            print "$filename: Error: enum definition '$enumname' cannot precede namespace declaration\n"; $ret=1;
        }
        $msg =~ s/<enum>//s; # remove the marker inserted above

        @fieldlist = ();
        undef %fval;

        #
        # parse enum { ... } syntax
        #
        $scrap = '';
        while ($fields =~ s/^(.*?);//s)
        {
            $field = $1;

            # value
            if ($field =~ s/=\s*(.*?)\s*$//s) {
                $fieldvalue = $1;
            } else {
                $fieldvalue = '';
            }

            # identifier
            if ($field =~ /^\s*([A-Za-z0-9_]+)\s*$/s) {
                $fieldname = $1;
            } else {
                $scrap .= $field;
                print "$filename: Error: missing identifier name in enum $enumname\n"; $ret=1;
            }

            if ($fieldname =~ /^($RESERVED_WORDS)$/) {
                print "$filename: Error: enum field name '$fieldname' is a reserved word\n"; $ret=1;
            }

            # store field
            push(@fieldlist,$fieldname);
            $fval{$fieldname}=$fieldvalue;

        }
        $scrap .= $fields;
        if ($scrap =~ /[^ \t\n]/s) {
            $scrap =~ s/\n\n+/\n\n/sg;
            $scrap =~ s/^\n+//s;
            $scrap =~ s/\n+$//s;
            print "$filename: Error: some parts not understood in enum $enumname:\n"; $ret=1;
            print "'$scrap'\n";
        }

        #
        # generate code
        #
        if (grep(/^\Q$enumname\E$/,@enums)) {
            print "$filename: Error: enum '$enumname' already defined\n"; $ret=1;
        }
        $enumqname = prefixWithNamespace($namespacename, $enumname);
        push(@enums, $enumqname);

        print H "/**\n";
        print H " * Enum generated from <tt>$filename</tt> by opp_msgc.\n";
        $source =~ s/^/ * /mg;
        print H " * <pre>\n$source\n * </pre>\n";
        print H " */\n";
        print H "enum $enumname {\n";
        foreach my $fieldname (@fieldlist)
        {
            print H "    $fieldname = $fval{$fieldname}";
            print H "," unless ($fieldname eq $fieldlist[$#fieldlist]);
            print H "\n";
        }
        print H "};\n\n";

        print CC "EXECUTE_ON_STARTUP(\n";
        print CC "    cEnum *e = cEnum::find(\"$enumqname\");\n";
        print CC "    if (!e) enums.getInstance()->add(e = new cEnum(\"$enumqname\"));\n";
        # enum inheritance: we should add fields from base enum as well, but that could only be done when importing is in place
        foreach my $fieldname (@fieldlist)
        {
            print CC "    e->insert($fieldname, \"$fieldname\");\n";
        }
        print CC ");\n\n";

    }

    # parse message/packet/class/struct definitions
    while ($msg =~ s/(message|packet|class|struct)\s+(.+?)\s*{(.*?)};?/<class>/s)
    {
        #
        # parse message { ... } syntax
        #
        $source = $&;
        $keyword = $1;  # 'message', 'packet', 'class' or 'struct'
        $msghdr = $2;   # must be "<name>" or "<name> extends <name>"
        $body = $3;

        # reset
        @fieldlist = ();
        @baseclassfieldlist = ();
        undef %fprops;
        undef %props;

        if ($msghdr =~ /^$NAME\s+extends\s+$QNAME$/s)
        {
            $msgname = $1;
            $msgbase = $2;
        }
        elsif ($msghdr =~ /^$NAME$/s)
        {
            $msgname = $msghdr;
            $msgbase = '';
        }
        else
        {
            $msghdr =~ s/\s+/ /sg;
            print "$filename: Error: invalid declaration syntax for '$msghdr'\n"; $ret=1;
            $msgname = "???";
            $msgbase = '';
        }

        if ($msgname =~ /^($RESERVED_WORDS)$/) {
            print "$filename: Error: type name '$msgname' is a reserved word\n"; $ret=1;
        }

        if ($msg =~ /<class>.*<namespace>/s) {
            print "$filename: Error: $keyword definition '$msgname' cannot precede namespace declaration\n"; $ret=1;
        }
        $msg =~ s/<class>//s;  # remove the marker inserted above

        $oldstyleproperties = "";
        $fieldsandproperties= "";

        #
        # match out part before "fields:" and "properties:"
        #
        $scrap = $body;
        $scrap =~ s/fields:(.*)$//s;
        $scrap =~ s/properties:(.*)$//s;
        if ($scrap =~ /[^ \t\n]/s)
        {
            $fieldsandproperties = $scrap;
        }

        #
        # match out "properties:" section (old 3.x syntax)
        #
        if ($body =~ /properties:(.*)$/s)
        {
            $oldstyleproperties = $1;
            $oldstyleproperties =~ s/fields:.*$//s;  # cut off fields section
            $obsoletesyntax = 1;
        }

        #
        # match out "fields:" section (old 3.x syntax)
        #
        if ($body =~ /fields:(.*)$/s)
        {
            $fieldsandproperties.= "\n" . $1;
            $obsoletesyntax = 1;
        }

        #
        # process $oldstyleproperties (old 3.x syntax)
        #
        $scrap = '';
        while ($oldstyleproperties =~ s/^(.*?);//s)
        {
            $prop = $1;
            if ($prop =~ /^\s*(.*?)\s*=\s*(.*?)\s*$/s)
            {
                $propname = $1;
                $propvalue = $2;
                $props{$propname} = $propvalue;

                if ($propname =~ /^($RESERVED_WORDS)$/) {
                    print "$filename: Error: property name '$propname' is a reserved word\n"; $ret=1;
                }
            }
            else {$scrap.=$prop;}
        }
        $scrap.=$oldstyleproperties;
        if ($scrap =~ /[^ \t\n]/s)
        {
            $scrap =~ s/\n\n+/\n\n/sg;
            $scrap =~ s/^\n+//s;
            $scrap =~ s/\n+$//s;
            print "$filename: Error: some parts not understood in the 'properties' section of '$msgname':\n"; $ret=1;
            print "'$scrap'\n";
        }

        #
        # process $fieldsandproperties
        #
        $scrap = '';
        while ($fieldsandproperties =~ s/^\s*(.*?)\s*;//s)
        {
            $fieldorproperty = $1;

            # is this a property? try it both as @foo(...) and @foo.
            # Note: foo() should be same as @foo, i.e. value=""
            #XXX property values cannot contain parens "(..)", because regex doesn't count parens, just stops at first ")"...
            if ($fieldorproperty =~ s/^\@$NAME\((.*?)\)$//s || $fieldorproperty =~ s/^\@$NAME$()//s) {
                # store property
                $propname = $1;
                $propvalue = $2;
                $props{$propname} = unquote($propvalue);

                if ($propname =~ /^($RESERVED_WORDS)$/) {
                    print "$filename: Error: property name '$propname' is a reserved word\n"; $ret=1;
                }
            }
            else {
                # parse as field
                $field = $fieldorproperty;

                # field properties, with @propertyname(value) syntax
                %fieldprop = ();
                $field =~ s|\@([_a-z0-9]+)\((.*?)\)|$fieldprop{$1}=unquote($2);""|gsei;
                $field =~ s|\@([_a-z0-9]+)|$fieldprop{$1}="";""|gsei;  # @props and @props() should be equivalent (value="")

                # abstract
                if ($field =~ s/^\s*abstract\s+//s) {
                    $isabstract = 1;
                    if ($keyword eq 'struct') {
                        print "$filename: Error: a struct cannot have abstract fields in '$msgname'\n"; $ret=1;
                    }
                } else {
                    $isabstract = 0;
                }

                #
                # NOTE: we cannot properly support 'readonly' fields in opp_msgc,
                # because we don't know if a field is new or it's already defined
                # in the base class! So we cannot decide we should put it into the
                # descriptor class or not.
                #
                # Implementing proper imports will solve this issue.
                #

                # enum() -- treat it as @enum()
                if ($field =~ s/enum\s*\((.*?)\)\s*//s) {
                    $fieldprop{"enum"} = $1;
                }

                # default value
                if ($field =~ s/=\s*(.*?)\s*$//s) {
                    $fieldvalue = $1;
                } else {
                    $fieldvalue = '';
                }

                # array
                if ($field =~ s/\[\s*(.*?)\s*\]\s*$//s) {
                    $isarray = 1;
                    $arraysize = $1;
                    if ($arraysize !~ /^[0-9]*$/ && $arraysize !~ /^[A-Za-z_][A-Za-z0-9_]*$/) {
                        print "$filename: Error: array size must be numeric or a symbolic constant (not '$arraysize') in '$msgname'\n"; $ret=1;
                    }
                    if ($arraysize eq '' && $keyword eq 'struct') {
                        print "$filename: Error: a struct cannot have dynamic array fields in '$msgname'\n"; $ret=1;
                    }
                } else {
                    $isarray = 0;
                    $arraysize = '';
                }

                # 'fieldtype fieldname'...
                if ($field =~ /^\s*([A-Za-z_:][A-Za-z0-9_:* \t\n]*[* \t\n])$NAME\s*$/s)
                {
                    $fieldtype = $1;
                    $fieldname = $2;
                    $fieldtype =~ s/\s*$//sg;
                    $fieldtype =~ s/\s+/ /sg;

                    # pointer?
                    if ($fieldtype =~ /^(.*?)\s*\*$/) {
                        $fieldtype = $1;
                        $fieldispointer = 1;
                    } else {
                        $fieldispointer = 0;
                    }

                    # various checks
                    if ($fieldname =~ /^($RESERVED_WORDS)$/) {
                        print "$filename: Error: field name '$fieldname' is a reserved word\n"; $ret=1;
                    }
                    if ($isabstract && $fieldvalue ne '') {
                        print "$filename: Error: an abstract field cannot be assigned a value in '$msgname'\n"; $ret=1;
                    }

                    # store
                    push(@fieldlist,$fieldname);
                    $ftype{$fieldname} = $fieldtype;
                    $fispointer{$fieldname} = $fieldispointer;
                    $fval{$fieldname} = $fieldvalue;
                    $fisabstract{$fieldname} = $isabstract;
                    $fisarray{$fieldname} = $isarray;
                    $farraysize{$fieldname} = $arraysize;
                    #print "$msgname field=$fieldname type=$ftype{$fieldname} value=$fval{$fieldname} isarray=$fisarray{$fieldname} arraysize=$farraysize{$fieldname}\n";
                    for $key (keys(%fieldprop)) {
                        $fprops{$fieldname}->{$key} = $fieldprop{$key};
                        #print "$key => $fprops{$fieldname}->{$key}\n";
                    }
                }
                # ...or just fieldname
                elsif ($field =~ /^\s*$NAME\s*$/s)
                {
                    $fieldname = $1;

                    # various checks
                    if ($fieldname =~ /^($RESERVED_WORDS)$/) {
                        print "$filename: Error: field name '$fieldname' is a reserved word\n"; $ret=1;
                    }
                    if ($isabstract) {
                        print "$filename: Error: an abstract field needs a type in '$msgname'\n"; $ret=1;
                    }
                    if ($isarray) {
                        print "$filename: Error: cannot set array field of the base class in '$msgname'\n"; $ret=1;
                    }
                    if ($fieldenum ne '') {
                        print "$filename: Error: cannot specify enum for base class field in '$msgname'\n"; $ret=1;
                    }
                    if ($fieldvalue eq '') {
                        print "$filename: Error: missing field type in '$msgname'\n"; $ret=1;
                    }

                    # store
                    push(@baseclassfieldlist,$fieldname);
                    $fval{$fieldname} = $fieldvalue;
                    #print "$msgname baseclassfield=$fieldname value=$fval{$fieldname}\n";
                }
                else {$scrap.=$field;}
            }
        }
        $scrap.=$fieldsandproperties;
        if ($scrap =~ /[^ \t\n]/s)
        {
            $scrap =~ s/\n\n+/\n\n/sg;
            $scrap =~ s/^\n+//s;
            $scrap =~ s/\n+$//s;
            print "$filename: Error: some parts not understood in '$msgname':\n"; $ret=1;
            print "'$scrap'\n";
        }

        # now generate code
        prepareForCodeGeneration();
        if ($generate_class) {
            if ($classtype eq 'struct') {
                generateStruct();
            } else {
                generateClass();
            }
        }
        if ($generate_descriptor) {
            generateDescriptorClass();
        }
    }

    if ($obsoletesyntax)
    {
        print "$filename: Warning: obsolete syntax: convert properties to the '\@' syntax (for example, change customize=true to \@customize(true)), and remove 'properties:' and 'fields:' keywords\n";
    }

    # remove marker
    $msg =~ s/<namespace>//s;

    $scrap = $msg;
    if ($scrap =~ /[^ \t\n]/s)
    {
        $scrap =~ s/\n\n+/\n\n/sg;
        $scrap =~ s/^\n//s;
        $scrap =~ s/\n$//s;
        print "$filename: Error: following parts of the input file were not understood:\n"; $ret=1;
        print "'$scrap'\n";
    }

    foreach my $i (split("::", $namespacename)) {
        print H "}; // end namespace $i\n";
        print CC "}; // end namespace $i\n";
    }
    print H "\n";
    print CC "\n";

    print H "#endif // $hdef\n";

    close(H);
    close(CC);

    if ($ret)
    {
        unlink($hfile);
        unlink($ccfile);
    }
}


#
# prepare for code generation
#
# in variables:
#
#  $keyword
#  $classtype
#  $gap
#  $omitgetverb
#  $msgclass
#  $realmsgclass
#  $msgbaseclass
#
#  $msgdescclass
#
#  $fieldcount
#  @fieldlist
#  %props
#
#  %ftype{fieldname}
#  %ftypeqname{fieldname}
#  %fval{fieldname}
#  %fisabstract{fieldname}
#  %fispointer{$fieldname}
#  %fisarray{fieldname}
#  %farraysize{fieldname}
#  %fsizetype{fieldname}
#  %fprops{fieldname}->{propname}
#
#  %fkind{fieldname}
#  %datatype{fieldname}
#  %argtype{fieldname}
#  %rettype{fieldname}
#  %var{fieldname}
#  %argname{fieldname}
#  %varsize{fieldname}
#  %getter{fieldname}
#  %setter{fieldname}
#  %alloc{fieldname}
#  %getsize{fieldname}
#  %tostring{fieldname}
#  %fromstring{fieldname}
#  %maybe_c_str{fieldname}
#

sub prepareForCodeGeneration()
{
    $msgqname = prefixWithNamespace($namespacename, $msgname);

    # determine $msgbaseqname
    if ($msgbase ne 'void') {
        my @found = lookupExistingClassName($namespacename, $msgbase);
        if (@found == 1) {
            $msgbaseqname = $found[0];
        } elsif (@found == 0) {
            print "$filename: Error: '$msgname': unknown base class '$msgbase'\n"; $ret=1;
            $msgbaseqname = 'cMessage';
        } else {
            print "$filename: Error: '$msgname': ambiguous base class '$msgbase'; possibilities: " .join(', ',@found)."\n"; $ret=1;
            $msgbaseqname = $found[0];
        }
    }

    # check base class and determine type of object
    if ($msgqname eq 'cObject' || $msgqname eq 'cNamedObject' || $msgqname eq 'cOwnedObject') {
        $classtype = $classtype{$msgqname};  # only for sim_std.msg
    }
    elsif ($msgbase eq '') {
        if ($keyword eq 'message' or $keyword eq 'packet') {
            $classtype = 'cownedobject';
        } elsif ($keyword eq 'class') {
            $classtype = 'cobject'; # Note: we never generate non-cObject classes
        } elsif ($keyword eq 'struct') {
            $classtype = 'struct';
        } else {
            die 'internal error';
        }
        # if announced earlier as noncpolymorphic, accept that.
        if (grep(/^\Q$msgqname\E$/,@classes)) {
            if ($classtype{$msgqname} eq 'foreign' && $classtype eq 'cobject') {
                $classtype = 'foreign';
            }
        }
    }
    elsif ($msgbase eq 'void') {
        $classtype = 'foreign';
    }
    elsif ($msgbaseqname ne '') {
        $classtype = $classtype{$msgbaseqname};
    }
    else {
        print "$filename: Error: unknown base class '$msgbase' for '$msgname'\n"; $ret=1;
        $classtype = 'cobject';
    }

    # check earlier declarations and register this class
    if (grep(/^\Q$msgqname\E$/,@classes)) {
        if (0) { # XXX add condition
            print "$filename: Error: attempt to redefine '$msgname'\n"; $ret=1;
        } elsif ($classtype{$msgqname} ne $classtype) {
            print "$filename: Error: definition of '$msgname' inconsistent with earlier declaration(s)\n"; $ret=1;
        }
    } else {
        push(@classes, $msgqname);
        $classtype{$msgqname} = $classtype;
    }

    #
    # produce all sorts of derived names
    #
    $generate_class = $generate_classes && !propertyAsBool($props{"existingClass"});
    $generate_descriptor = $generate_descriptors && ($props{"descriptor"} ne "false");
    $generate_setters_in_descriptor = $generate_setters_in_descriptors && ($props{"descriptor"} ne "readonly");

    if (propertyAsBool($props{"customize"})) {
        $gap = 1;
        $msgclass = $msgname."_Base";
        $realmsgclass = $msgname;
        $msgdescclass = $realmsgclass."Descriptor";
    } else {
        $gap = 0;
        $msgclass = $msgname;
        $realmsgclass = $msgname;
        $msgdescclass = $msgclass."Descriptor";
    }
    if ($msgbase eq '') {
        if ($msgqname eq 'cObject') {
            $msgbaseclass = '';
        } elsif ($keyword eq 'message') {
            $msgbaseclass = 'cMessage';
        } elsif ($keyword eq 'packet') {
            $msgbaseclass = 'cPacket';
        } elsif ($keyword eq 'class') {
            $msgbaseclass = 'cObject';  # note: all classes we generate subclass from cObject!
        } elsif ($keyword eq 'struct') {
            $msgbaseclass = '';
        } else {
            die 'internal error';
        }
    } elsif ($msgbase eq 'void') {
        $msgbaseclass = '';
    } else {
        $msgbaseclass = $msgbaseqname;
    }

    $omitgetverb = propertyAsBool($props{"omitGetVerb"});

    foreach my $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname} && !$gap) {
            print "$filename: Error: abstract fields need '\@customize(true)' property in '$msgname'\n"; $ret=1;
        }

        if ($generate_class) {
           if ($classtype{$ftype{$fieldname}} eq 'cownedobject' && ($classtype ne 'cownedobject')) {
               print "$filename: Error: cannot use cOwnedObject field '$ftype{$fieldname} $fieldname' in struct or non-cOwnedObject class '$msgname'\n"; $ret=1;
           }
        }

        # resolve enum namespace
        my $enumname = $fprops{$fieldname}->{"enum"};
        if (defined($enumname)) {
            my @found = lookupExistingEnumName($namespacename, $enumname);
            if (@found == 1) {
                $enumqname = $found[0];
            } elsif (@found == 0) {
                print "$filename: Error: undeclared enum '$enumname' in field '$fieldname' in '$msgname'\n"; $ret=1;
                $enumqname = '';
            } else {
                print "$filename: Error: ambiguous enum '$enumname' in field '$fieldname' in '$msgname';  possibilities: ".join(', ',@found)."\n"; $ret=1;
                $enumqname = $found[0];
            }
            $fprops{$fieldname}->{"enum"} = $enumqname; # need to modify the property in place
        }

        # variable name
        if ($classtype eq 'struct') {
            $var{$fieldname} = $fieldname;
        } else {
            $var{$fieldname} = $fieldname . "_var";
            $argname{$fieldname} = $fieldname;
        }

        $varsize{$fieldname} = $fieldname."_arraysize";
        my $sizetypeprop = $fprops{$fieldname}->{sizetype};
        $fsizetype{$fieldname} = ($sizetypeprop ne '') ? $sizetypeprop : "unsigned int";

        # method names
        if ($classtype ne 'struct') {
            $capfieldname = $fieldname;
            $capfieldname =~ s/(.)(.*)/uc($1).$2/e;
            $setter{$fieldname} = "set".$capfieldname;
            $alloc{$fieldname} = "set".$capfieldname."ArraySize";
            if ($omitgetverb) {
                $getter{$fieldname} = $fieldname;
                $getsize{$fieldname} = $fieldname."ArraySize";
            } else {
                $getter{$fieldname} = "get".$capfieldname;
                $getsize{$fieldname} = "get".$capfieldname."ArraySize";
            }

            # allow customization of names
            if ($fprops{$fieldname}->{setter} ne '') {
                $setter{$fieldname} = $fprops{$fieldname}->{setter};
            }
            if ($fprops{$fieldname}->{getter} ne '') {
                $getter{$fieldname} = $fprops{$fieldname}->{getter};
            }
            if ($fprops{$fieldname}->{sizeSetter} ne '') {
                $alloc{$fieldname} = $fprops{$fieldname}->{sizeSetter};
            }
            if ($fprops{$fieldname}->{sizeGetter} ne '') {
                $getsize{$fieldname} = $fprops{$fieldname}->{sizeGetter};
            }
        }

        $ftype = $ftype{$fieldname};

        # determine field data type
        if ($ftype =~ /^($PRIMITIVE_TYPES)$/) {
            $fkind{$fieldname} = 'basic';
            $ftypeqname = '';  #unused
        }
        else {
            $fkind{$fieldname} = 'struct';

            # $ftypeqname
            my @found = lookupExistingClassName($namespacename, $ftype);
            if (@found == 1) {
                $ftypeqname = "::" . $found[0];
            } elsif (@found == 0) {
                print "$filename: Error: unknown type '$ftype' for field '$fieldname' in '$msgname'\n"; $ret=1;
                $ftypeqname = '::cObject';
            } else {
                print "$filename: Error: unknown type '$ftype' for field '$fieldname' in '$msgname'; possibilities: " .join(', ',@found)."\n"; $ret=1;
                $ftypeqname = "::" . $found[0];
            }
        }
        $ftypeqname{$fieldname} = $ftypeqname;  # unused!

        # data type, argument type, conversion to/from string...
        $maybe_c_str{$fieldname} = "";
        if ($fkind{$fieldname} eq 'struct') {
            $datatype{$fieldname} = "$ftype";
            $argtype{$fieldname} = "const $ftype&";
            $rettype{$fieldname} = "$ftype&";
            $tostring{$fieldname} = "";
            $fromstring{$fieldname} = "";
            #$fval{$fieldname} = '' unless ($fval{$fieldname} ne '');
        } elsif ($fkind{$fieldname} eq 'basic') {
            # defaults:
            $datatype{$fieldname} = $ftype;
            $argtype{$fieldname} = $ftype;
            $rettype{$fieldname} = $ftype;
            $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');

            if ($ftype eq "bool") {
                # $datatype, $argtype, $rettype: default (same as $ftype)
                $tostring{$fieldname} = "bool2string";
                $fromstring{$fieldname} = "string2bool";
                $fval{$fieldname} = 'false' unless ($fval{$fieldname} ne '');
            } elsif ($ftype =~ /^(char|short|int|long|int8|int16|int32|int8_t|int16_t|int32_t)$/) {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
            } elsif ($ftype =~ /^unsigned (char|short|int|long)$/) {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "ulong2string";
                $fromstring{$fieldname} = "string2ulong";
            } elsif ($ftype =~ /^(uint8|uint16|uint32|uint8_t|uint16_t|uint32_t)$/) {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "ulong2string";
                $fromstring{$fieldname} = "string2ulong";
            } elsif ($ftype =~ /^(int64|int64_t)$/) {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "int642string";
                $fromstring{$fieldname} = "string2int64";
            } elsif ($ftype =~ /^(uint64|uint64_t)$/) {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "uint642string";
                $fromstring{$fieldname} = "string2uint64";
            } elsif ($ftype eq "float") {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "double2string";
                $fromstring{$fieldname} = "string2double";
            } elsif ($ftype eq "double") {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "double2string";
                $fromstring{$fieldname} = "string2double";
            } elsif ($ftype eq "simtime_t") {
                # $datatype, $argtype, $rettype, $fval: default (same as $ftype)
                $tostring{$fieldname} = "double2string";
                $fromstring{$fieldname} = "string2double";
            } elsif ($ftype eq "string") {
                $datatype{$fieldname} = "opp_string";
                $argtype{$fieldname} = "const char *";
                $rettype{$fieldname} = "const char *";
                $tostring{$fieldname} = "oppstring2string";
                $fromstring{$fieldname} = "";
                $fval{$fieldname} = '""' unless ($fval{$fieldname} ne '');
                $maybe_c_str{$fieldname} = ".c_str()";
            } else {
                die "internal error - unknown primitive data type '$ftype'";
            }
        } else {
            die 'internal error';
        }
    }
}


#
# print class
#
sub generateClass
{
    print H "/**\n";
    print H " * Class generated from <tt>$filename</tt> by opp_msgc.\n";
    $source =~ s/^/ * /mg;
    print H " * <pre>\n$source\n * </pre>\n";

    if ($gap)
    {
        print H " *\n";
        print H " * $msgclass is only useful if it gets subclassed, and $realmsgclass is derived from it.\n";
        print H " * The minimum code to be written for $realmsgclass is the following:\n";
        print H " *\n";
        print H " * <pre>\n";
        print H " * class $exportdef$realmsgclass : public $msgclass\n";
        print H " * {\n";
        print H " *   private:\n";
        print H " *     void copy(const $realmsgclass& other) { ... }\n\n";
        print H " *   public:\n";
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject") {
            if ($keyword eq "message" or $keyword eq "packet") {
                print H " *     $realmsgclass(const char *name=NULL, int kind=0) : $msgclass(name,kind) {}\n";
            } else {
                print H " *     $realmsgclass(const char *name=NULL) : $msgclass(name) {}\n";
            }
        } else {
            print H " *     $realmsgclass() : $msgclass() {}\n";
        }
        print H " *     $realmsgclass(const $realmsgclass& other) : $msgclass(other) {copy(other);}\n";
        print H " *     $realmsgclass& operator=(const $realmsgclass& other) {if (this==&other) return *this; $msgclass\:\:operator=(other); copy(other); return *this;}\n";
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject" || $classtype eq "cobject") {
            print H " *     virtual $realmsgclass *dup() const {return new $realmsgclass(*this);}\n";
        }
        print H " *     // ADD CODE HERE to redefine and implement pure virtual functions from $msgclass\n";
        print H " * };\n";
        print H " * </pre>\n";
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject" || $classtype eq "cobject") {
            print H " *\n";
            print H " * The following should go into a .cc (.cpp) file:\n";
            print H " *\n";
            print H " * <pre>\n";
            print H " * Register_Class($realmsgclass);\n";
            print H " * </pre>\n";
        }
    }
    print H " */\n";
    if ($msgbaseclass eq "") {
        print H "class $exportdef$msgclass\n";
    } else {
        print H "class $exportdef$msgclass : public \:\:$msgbaseclass";  # make namespace explicit and absolute to disambiguate the way opp_msgc understood it
    }
    if (defined($props{"implements"})) {
        foreach my $interface (split(',', $props{"implements"})) {
            $interface =~ s/^\s+|\s+$//g;
            print H ", public $interface";
        }
    }
    print H "\n{\n";
    print H "  protected:\n";
    foreach my $fieldname (@fieldlist)
    {
        if ($fispointer{$fieldname}) {
            print "$filename: Error: pointers not supported yet in '$msgname'\n"; $ret=1; return;
        }
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print H "    $datatype{$fieldname} $var{$fieldname}\[$farraysize{$fieldname}\];\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print H "    $datatype{$fieldname} *$var{$fieldname}; // array ptr\n";
                print H "    $fsizetype{$fieldname} $varsize{$fieldname};\n";
            } else {
                print H "    $datatype{$fieldname} $var{$fieldname};\n";
            }
        }
    }
    print H "\n";
    print H "  private:\n";
    print H "    void copy(const $msgclass& other);\n\n";
    print H "  protected:\n";
    print H "    // protected and unimplemented operator==(), to prevent accidental usage\n";
    print H "    bool operator==(const $msgclass&);\n";
    if ($gap) {
        print H "    // make constructors protected to avoid instantiation\n";
    } else {
        print H "\n";
        print H "  public:\n";
    }
    if ($classtype eq "cownedobject" || $classtype eq "cnamedobject") {
        if ($keyword eq "message" or $keyword eq "packet") {
            print H "    $msgclass(const char *name=NULL, int kind=0);\n";
        } else {
            print H "    $msgclass(const char *name=NULL);\n";
        }
    } else {
        print H "    $msgclass();\n";
    }
    print H "    $msgclass(const $msgclass& other);\n";
    if ($gap) {
        print H "    // make assignment operator protected to force the user override it\n";
        print H "    $msgclass& operator=(const $msgclass& other);\n";
        print H "\n";
        print H "  public:\n";
    }
    print H "    virtual ~$msgclass();\n";
    if (!$gap) {
        print H "    $msgclass& operator=(const $msgclass& other);\n";
    }
    if ($gap) {
        print H "    virtual $msgclass *dup() const {throw cRuntimeError(\"You forgot to manually add a dup() function to class $realmsgclass\");}\n";
    } else {
        print H "    virtual $msgclass *dup() const {return new $msgclass(*this);}\n";
    }
    print H "    virtual void parsimPack(cCommBuffer *b);\n";
    print H "    virtual void parsimUnpack(cCommBuffer *b);\n";
    print H "\n";
    print H "    // field getter/setter methods\n";
    foreach my $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname}) {
            $pure = ' = 0';
        } else {
            $pure = '';
        }
        $isstruct = ($fkind{$fieldname} eq 'struct');
        $constifprimitivetype = (!$isstruct ? ' const' : '');
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
            print H "    virtual $fsizetype{$fieldname} $getsize{$fieldname}() const$pure;\n";
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}($fsizetype{$fieldname} k)$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}($fsizetype{$fieldname} k) const {return const_cast<$msgclass*>(this)->$getter{$fieldname}(k);}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}($fsizetype{$fieldname} k, $argtype{$fieldname} $argname{$fieldname})$pure;\n";
        } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
            print H "    virtual void $alloc{$fieldname}($fsizetype{$fieldname} size)$pure;\n";
            print H "    virtual $fsizetype{$fieldname} $getsize{$fieldname}() const$pure;\n";
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}($fsizetype{$fieldname} k)$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}($fsizetype{$fieldname} k) const {return const_cast<$msgclass*>(this)->$getter{$fieldname}(k);}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}($fsizetype{$fieldname} k, $argtype{$fieldname} $argname{$fieldname})$pure;\n";
        } else {
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}()$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}() const {return const_cast<$msgclass*>(this)->$getter{$fieldname}();}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}($argtype{$fieldname} $argname{$fieldname})$pure;\n";
        }
    }
    print H "};\n\n";

    if (!$gap) {
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject" || $classtype eq "cobject") {
            print CC "Register_Class($msgclass);\n\n";
        }
        print H "inline void doPacking(cCommBuffer *b, $realmsgclass& obj) {obj.parsimPack(b);}\n";
        print H "inline void doUnpacking(cCommBuffer *b, $realmsgclass& obj) {obj.parsimUnpack(b);}\n\n";
    }

    if ($classtype eq "cownedobject" || $classtype eq "cnamedobject") {
        if ($keyword eq "message" or $keyword eq "packet") {
            # CAREFUL when assigning values to existing members gets implemented!
            # The msg kind passed to the ctor should take priority!!!
            print CC "$msgclass\:\:$msgclass(const char *name, int kind) : \:\:$msgbaseclass(name,kind)\n";
        } else {
            if ($msgbaseclass eq "") {
                print CC "$msgclass\:\:$msgclass(const char *name)\n";
            } else {
                print CC "$msgclass\:\:$msgclass(const char *name) : \:\:$msgbaseclass(name)\n";
            }
        }
    } else {
        if ($msgbaseclass eq "") {
            print CC "$msgclass\:\:$msgclass()\n";
        } else {
            print CC "$msgclass\:\:$msgclass() : \:\:$msgbaseclass()\n";
        }
    }
    print CC "{\n";
    #print CC "    (void)static_cast<cObject *>(this); //sanity check\n" if ($fieldclasstype eq 'cobject');
    #print CC "    (void)static_cast<cNamedObject *>(this); //sanity check\n" if ($fieldclasstype eq 'cnamedobject');
    #print CC "    (void)static_cast<cOwnedObject *>(this); //sanity check\n" if ($fieldclasstype eq 'cownedobject');
    foreach my $fieldname (@baseclassfieldlist)
    {
        $capfieldname = $fieldname;
        $capfieldname =~ s/(.)(.*)/uc($1).$2/e;
        $setter = "set".$capfieldname;
        print CC "    this->$setter($fval{$fieldname});\n";
    }
    print CC "\n" if (@baseclassfieldlist!=() && @fieldlist!=());
    foreach my $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                if ($fkind{$fieldname} eq 'basic') {
                    print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        this->$var{$fieldname}\[i\] = $fval{$fieldname};\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                  print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                  print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
                }
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    $varsize{$fieldname} = 0;\n";
                print CC "    this->$var{$fieldname} = 0;\n";
            } else {
                if ($fval{$fieldname} ne '') {
                  print CC "    this->$var{$fieldname} = $fval{$fieldname};\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                  print CC "    take(&(this->$var{$fieldname}));\n";
                }
            }
        }
    }
    print CC "}\n\n";
    if ($msgbaseclass eq "") {
        print CC "$msgclass\:\:$msgclass(const $msgclass& other)\n";
    } else {
        print CC "$msgclass\:\:$msgclass(const $msgclass& other) : \:\:$msgbaseclass(other)\n";
    }
    print CC "{\n";
    foreach my $fieldname (@fieldlist)
    {
      if (!$fisabstract{$fieldname}) {
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
          if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
            print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
            print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
          }
        } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
          print CC "    $varsize{$fieldname} = 0;\n";
          print CC "    this->$var{$fieldname} = 0;\n";
        } elsif (!$fisarray{$fieldname} && $classtype{$ftype{$fieldname}} eq 'cownedobject') {
          print CC "    take(&(this->$var{$fieldname}));\n";
        }
      }
    }
    print CC "    copy(other);\n";
    print CC "}\n\n";
    print CC "$msgclass\:\:~$msgclass()\n";
    print CC "{\n";
    foreach my $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                if (!$fisarray{$fieldname}) {
                    print CC "    drop(&(this->$var{$fieldname}));\n";
                } elsif ($farraysize{$fieldname} ne '') {
                    print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        drop(&(this->$var{$fieldname}\[i\]));\n";
                } else {
                    print CC "    for ($fsizetype{$fieldname} i=0; i<$varsize{$fieldname}; i++)\n";
                    print CC "        drop(&(this->$var{$fieldname}\[i\]));\n";
                }
            }
            if ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] $var{$fieldname};\n";
            }
        }
    }
    print CC "}\n\n";
    print CC "$msgclass& $msgclass\:\:operator=(const $msgclass& other)\n";
    print CC "{\n";
    print CC "    if (this==&other) return *this;\n";
    if ($msgbaseclass ne "") {
        print CC "    \:\:$msgbaseclass\:\:operator=(other);\n";
    }
    print CC "    copy(other);\n";
    print CC "    return *this;\n";
    print CC "}\n\n";
    print CC "void $msgclass\:\:copy(const $msgclass& other)\n";
    print CC "{\n";
    foreach my $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                    print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        this->$var{$fieldname}\[i\].setName(other.$var{$fieldname}\[i\].getName());\n";
                }
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    this->$var{$fieldname} = (other.$varsize{$fieldname}==0) ? NULL : new $datatype{$fieldname}\[other.$varsize{$fieldname}\];\n";
                print CC "    $varsize{$fieldname} = other.$varsize{$fieldname};\n";
                print CC "    for ($fsizetype{$fieldname} i=0; i<$varsize{$fieldname}; i++)\n";
                if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                    print CC "    {\n";
                    print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
                    print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                    print CC "        this->$var{$fieldname}\[i\].setName(other.$var{$fieldname}\[i\].getName());\n";
                    print CC "    }\n";
                } else {
                    print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                }
            } else {
                print CC "    this->$var{$fieldname} = other.$var{$fieldname};\n";
                if (!$fisarray{$fieldname} && ($classtype{$ftype{$fieldname}} eq 'cownedobject' || $classtype{$ftype{$fieldname}} eq 'cnamedobject')) {
                    print CC "    this->$var{$fieldname}.setName(other.$var{$fieldname}.getName());\n";
                }
            }
        }
    }
    print CC "}\n\n";

    #
    # Note: This class may not be derived from cOwnedObject, and then this parsimPack()/
    # parsimUnpack() is NOT that of cOwnedObject. However it's still needed because a
    # "friend" doPacking() function could not access protected members otherwise.
    #
    print CC "void $msgclass\:\:parsimPack(cCommBuffer *b)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject" || $classtype eq "cobject") {
            print CC "    \:\:$msgbaseclass\:\:parsimPack(b);\n" unless ($msgbaseclass eq "cObject");
        } else {
            print CC "    doPacking(b,(\:\:$msgbaseclass&)*this);\n"; # this would do for cOwnedObject too, but the other is nicer
        }
    }
    foreach my $fieldname (@fieldlist)
    {
        if (propertyAsBool($fprops{$fieldname}->{nopack})) {
            # @nopack specified
        } elsif ($fisabstract{$fieldname}) {
            print CC "    // field $fieldname is abstract -- please do packing in customized class\n";
        } else {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    doPacking(b,this->$var{$fieldname},$farraysize{$fieldname});\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    b->pack($varsize{$fieldname});\n";
                print CC "    doPacking(b,this->$var{$fieldname},$varsize{$fieldname});\n";
            } else {
                print CC "    doPacking(b,this->$var{$fieldname});\n";
            }
        }
    }
    print CC "}\n\n";

    print CC "void $msgclass\:\:parsimUnpack(cCommBuffer *b)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        if ($classtype eq "cownedobject" || $classtype eq "cnamedobject" || $classtype eq "cobject") {
            print CC "    \:\:$msgbaseclass\:\:parsimUnpack(b);\n" unless ($msgbaseclass eq "cObject");
        } else {
            print CC "    doUnpacking(b,(\:\:$msgbaseclass&)*this);\n"; # this would do for cOwnedObject too, but the other is nicer
        }
    }
    foreach my $fieldname (@fieldlist)
    {
        if (propertyAsBool($fprops{$fieldname}->{nopack})) {
            # @nopack specified
        } elsif ($fisabstract{$fieldname}) {
            print CC "    // field $fieldname is abstract -- please do unpacking in customized class\n";
        } else {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    doUnpacking(b,this->$var{$fieldname},$farraysize{$fieldname});\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    b->unpack($varsize{$fieldname});\n";
                print CC "    if ($varsize{$fieldname}==0) {\n";
                print CC "        this->$var{$fieldname} = 0;\n";
                print CC "    } else {\n";
                print CC "        this->$var{$fieldname} = new $datatype{$fieldname}\[$varsize{$fieldname}\];\n";
                print CC "        doUnpacking(b,this->$var{$fieldname},$varsize{$fieldname});\n";
                print CC "    }\n";
            } else {
                print CC "    doUnpacking(b,this->$var{$fieldname});\n";
            }
        }
    }
    print CC "}\n\n";

    foreach my $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            $isstruct = ($fkind{$fieldname} eq 'struct');
            $constifprimitivetype = (!$isstruct ? ' const' : '');
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "$fsizetype{$fieldname} $msgclass\:\:$getsize{$fieldname}() const\n";
                print CC "{\n";
                print CC "    return $farraysize{$fieldname};\n";
                print CC "}\n\n";
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}($fsizetype{$fieldname} k)$constifprimitivetype\n";
                print CC "{\n";
                print CC "    if (k>=$farraysize{$fieldname}) throw cRuntimeError(\"Array of size $farraysize{$fieldname} indexed by \%lu\", (unsigned long)k);\n";
                print CC "    return $var{$fieldname}\[k\]$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}($fsizetype{$fieldname} k, $argtype{$fieldname} $argname{$fieldname})\n";
                print CC "{\n";
                print CC "    if (k>=$farraysize{$fieldname}) throw cRuntimeError(\"Array of size $farraysize{$fieldname} indexed by \%lu\", (unsigned long)k);\n";
                print CC "    this->$var{$fieldname}\[k\] = $argname{$fieldname};\n";
                print CC "}\n\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "void $msgclass\:\:$alloc{$fieldname}($fsizetype{$fieldname} size)\n";
                print CC "{\n";
                print CC "    $datatype{$fieldname} *$var{$fieldname}2 = (size==0) ? NULL : new $datatype{$fieldname}\[size\];\n";
                print CC "    $fsizetype{$fieldname} sz = $varsize{$fieldname} < size ? $varsize{$fieldname} : size;\n";
                print CC "    for ($fsizetype{$fieldname} i=0; i<sz; i++)\n";
                print CC "        $var{$fieldname}2\[i\] = this->$var{$fieldname}\[i\];\n";
                if ($fkind{$fieldname} eq 'basic') {
                    print CC "    for ($fsizetype{$fieldname} i=sz; i<size; i++)\n";
                    print CC "        $var{$fieldname}2\[i\] = 0;\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cownedobject') {
                    print CC "    for ($fsizetype{$fieldname} i=sz; i<size; i++)\n";
                    print CC "        take(&($var{$fieldname}2\[i\]));\n";
                }
                print CC "    $varsize{$fieldname} = size;\n";
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    this->$var{$fieldname} = $var{$fieldname}2;\n";
                print CC "}\n\n";
                print CC "$fsizetype{$fieldname} $msgclass\:\:$getsize{$fieldname}() const\n";
                print CC "{\n";
                print CC "    return $varsize{$fieldname};\n";
                print CC "}\n\n";
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}($fsizetype{$fieldname} k)$constifprimitivetype\n";
                print CC "{\n";
                print CC "    if (k>=$varsize{$fieldname}) throw cRuntimeError(\"Array of size \%d indexed by \%d\", $varsize{$fieldname}, k);\n";
                print CC "    return $var{$fieldname}\[k\]$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}($fsizetype{$fieldname} k, $argtype{$fieldname} $argname{$fieldname})\n";
                print CC "{\n";
                print CC "    if (k>=$varsize{$fieldname}) throw cRuntimeError(\"Array of size \%d indexed by \%d\", $varsize{$fieldname}, k);\n";
                print CC "    this->$var{$fieldname}\[k\] = $argname{$fieldname};\n";
                print CC "}\n\n";
            } else {
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}()$constifprimitivetype\n";
                print CC "{\n";
                print CC "    return $var{$fieldname}$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}($argtype{$fieldname} $argname{$fieldname})\n";
                print CC "{\n";
                print CC "    this->$var{$fieldname} = $argname{$fieldname};\n";
                print CC "}\n\n";
            }
        }
    }
}


#
# print struct
#
sub generateStruct
{
    print H "/**\n";
    print H " * Struct generated from $filename by opp_msgc.\n";
    print H " */\n";
    if ($msgbaseclass eq "") {
        print H "struct $exportdef$msgclass\n";
    } else {
        print H "struct $exportdef$msgclass : public \:\:$msgbaseclass\n";
    }
    print H "{\n";
    print H "    $msgclass();\n";
    foreach my $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print H "    $datatype{$fieldname} $var{$fieldname}\[$farraysize{$fieldname}\];\n";
        } else {
            print H "    $datatype{$fieldname} $var{$fieldname};\n";
        }
    }
    print H "};\n\n";

    print H "void $exportdef"."doPacking(cCommBuffer *b, $msgclass& a);\n";
    print H "void $exportdef"."doUnpacking(cCommBuffer *b, $msgclass& a);\n\n";

    print CC "$msgclass\:\:$msgclass()\n";
    print CC "{\n";
    foreach my $fieldname (@baseclassfieldlist)
    {
        print CC "    this->$fieldname = $fval{$fieldname};\n";
    }
    print CC "\n" if (@baseclassfieldlist!=() && @fieldlist!=());
    foreach my $fieldname (@fieldlist)
    {
        die "abstract field not possible in struct" if ($fisabstract{$fieldname});
        die "cOwnedObject field not possible in struct" if ($classtype{$ftype{$fieldname}} eq 'cownedobject');
        die "dynamic array not possible in struct" if ($fisarray{$fieldname} && $farraysize{$fieldname} eq '');
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
            if ($fkind{$fieldname} eq 'basic') {
                print CC "    for ($fsizetype{$fieldname} i=0; i<$farraysize{$fieldname}; i++)\n";
                print CC "        $var{$fieldname}\[i\] = $fval{$fieldname};\n";
            }
        } else {
            if ($fval{$fieldname} ne '') {
                print CC "    $var{$fieldname} = $fval{$fieldname};\n";
            }
        }
    }
    print CC "}\n\n";
    print CC "void doPacking(cCommBuffer *b, $msgclass& a)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        print CC "    doPacking(b,(\:\:$msgbaseclass&)a);\n";
    }
    foreach my $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print CC "    doPacking(b,a.$var{$fieldname},$farraysize{$fieldname});\n";
        } else {
            print CC "    doPacking(b,a.$var{$fieldname});\n";
        }
    }
    print CC "}\n\n";

    print CC "void doUnpacking(cCommBuffer *b, $msgclass& a)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        print CC "    doUnpacking(b,(\:\:$msgbaseclass&)a);\n";
    }
    foreach my $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print CC "    doUnpacking(b,a.$var{$fieldname},$farraysize{$fieldname});\n";
        } else {
            print CC "    doUnpacking(b,a.$var{$fieldname});\n";
        }
    }
    print CC "}\n\n";
}


#
# print descriptor class
#
sub generateDescriptorClass
{
    print CC "class $msgdescclass : public cClassDescriptor\n";
    print CC "{\n";
    print CC "  public:\n";
    print CC "    $msgdescclass();\n";
    print CC "    virtual ~$msgdescclass();\n";
    print CC "\n";
    print CC "    virtual bool doesSupport(cObject *obj) const;\n";
    print CC "    virtual const char *getProperty(const char *propertyname) const;\n";
    print CC "    virtual int getFieldCount(void *object) const;\n";
    print CC "    virtual const char *getFieldName(void *object, int field) const;\n";
    print CC "    virtual int findField(void *object, const char *fieldName) const;\n";
    print CC "    virtual unsigned int getFieldTypeFlags(void *object, int field) const;\n";
    print CC "    virtual const char *getFieldTypeString(void *object, int field) const;\n";
    print CC "    virtual const char *getFieldProperty(void *object, int field, const char *propertyname) const;\n";
    print CC "    virtual int getArraySize(void *object, int field) const;\n";
    print CC "\n";
    print CC "    virtual std::string getFieldAsString(void *object, int field, int i) const;\n";
    print CC "    virtual bool setFieldAsString(void *object, int field, int i, const char *value) const;\n";
    print CC "\n";
    print CC "    virtual const char *getFieldStructName(void *object, int field) const;\n";
    print CC "    virtual void *getFieldStructPointer(void *object, int field, int i) const;\n";
    print CC "};\n\n";

    # register class
    print CC "Register_ClassDescriptor($msgdescclass);\n\n";

    # ctor, dtor
    $fieldcount = $#fieldlist+1;
    my $qualifiedrealmsgclass = prefixWithNamespace($namespacename, $realmsgclass);
    print CC "$msgdescclass\:\:$msgdescclass() : cClassDescriptor(\"$qualifiedrealmsgclass\", \"$msgbaseclass\")\n";
    print CC "{\n";
    print CC "}\n";
    print CC "\n";

    print CC "$msgdescclass\:\:~$msgdescclass()\n";
    print CC "{\n";
    print CC "}\n";
    print CC "\n";

    # doesSupport()
    print CC "bool $msgdescclass\:\:doesSupport(cObject *obj) const\n";
    print CC "{\n";
    print CC "    return dynamic_cast<$msgclass *>(obj)!=NULL;\n";
    print CC "}\n";
    print CC "\n";

    # getProperty()
    print CC "const char *$msgdescclass\:\:getProperty(const char *propertyname) const\n";
    print CC "{\n";
    for $key (keys %props) {
        $prop = quote($props{$key});
        print CC "    if (!strcmp(propertyname,\"$key\")) return \"$prop\";\n";
    }
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    return basedesc ? basedesc->getProperty(propertyname) : NULL;\n";
    print CC "}\n";
    print CC "\n";

    # getFieldCount()
    print CC "int $msgdescclass\:\:getFieldCount(void *object) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    return basedesc ? $fieldcount+basedesc->getFieldCount(object) : $fieldcount;\n";
    print CC "}\n";
    print CC "\n";

    # getFieldTypeFlags()
    print CC "unsigned int $msgdescclass\:\:getFieldTypeFlags(void *object, int field) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldTypeFlags(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    if ($fieldcount == 0) {
        print CC "    return 0;\n";
    } else {
        print CC "    static unsigned int fieldTypeFlags[] = {\n";
        for (my $i=0; $i<$fieldcount; $i++)
        {
            @flags = ();
            $fieldname = $fieldlist[$i];
            push(@flags, "FD_ISARRAY") if ($fisarray{$fieldname});
            push(@flags, "FD_ISCOMPOUND") if ($fkind{$fieldname} eq 'struct');
            push(@flags, "FD_ISPOINTER") if ($fispointer{$fieldname});
            push(@flags, "FD_ISCOBJECT") if ($classtype{$ftype{$fieldname}} eq 'cobject' || $classtype{$ftype{$fieldname}} eq 'cnamedobject');
            push(@flags, "FD_ISCOBJECT | FD_ISCOWNEDOBJECT") if ($classtype{$ftype{$fieldname}} eq 'cownedobject');

            my $editable = propertyAsBool($fprops{$fieldname}->{editable});
            push(@flags, "FD_ISEDITABLE") if ($editable || ($generate_setters_in_descriptor && $fkind{$fieldname} eq 'basic'));
            $flags = join(" | ", @flags);
            $flags = "0" if (@flags==());
            print CC "        $flags,\n";
        }
        print CC "    };\n";
        print CC "    return (field>=0 && field<$fieldcount) ? fieldTypeFlags[field] : 0;\n";
    }
    print CC "}\n";
    print CC "\n";

    # getFieldName()
    print CC "const char *$msgdescclass\:\:getFieldName(void *object, int field) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldName(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    if ($fieldcount == 0) {
        print CC "    return NULL;\n";
    } else {
        print CC "    static const char *fieldNames[] = {\n";
        for (my $i=0; $i<$fieldcount; $i++)
        {
            print CC "        \"$fieldlist[$i]\",\n";
        }
        print CC "    };\n";
        print CC "    return (field>=0 && field<$fieldcount) ? fieldNames[field] : NULL;\n";
    }
    print CC "}\n";
    print CC "\n";

    # findField()
    print CC "int $msgdescclass\:\:findField(void *object, const char *fieldName) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    if ($fieldcount > 0) {
        print CC "    int base = basedesc ? basedesc->getFieldCount(object) : 0;\n";
        for (my $i=0; $i<$fieldcount; $i++)
        {
            my $c = substr($fieldlist[$i], 0, 1);
            print CC "    if (fieldName[0]=='$c' && strcmp(fieldName, \"$fieldlist[$i]\")==0) return base+$i;\n";
        }
    }
    print CC "    return basedesc ? basedesc->findField(object, fieldName) : -1;\n";
    print CC "}\n";
    print CC "\n";

    # getFieldTypeString()
    print CC "const char *$msgdescclass\:\:getFieldTypeString(void *object, int field) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldTypeString(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    if ($fieldcount == 0) {
        print CC "    return NULL;\n";
    } else {
        print CC "    static const char *fieldTypeStrings[] = {\n";
        for (my $i=0; $i<$fieldcount; $i++)
        {
            print CC "        \"$ftype{$fieldlist[$i]}\",\n"; # note: NOT $fieldtypeqname! that's getFieldStructName()
        }
        print CC "    };\n";
        print CC "    return (field>=0 && field<$fieldcount) ? fieldTypeStrings[field] : NULL;\n";
    }
    print CC "}\n";
    print CC "\n";

    # getFieldProperty()
    print CC "const char *$msgdescclass\:\:getFieldProperty(void *object, int field, const char *propertyname) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldProperty(object, field, propertyname);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for (my $i=0; $i<$fieldcount; $i++)
    {
        my $fieldname = $fieldlist[$i];
        my $ref = $fprops{$fieldname};
        if (keys(%$ref) != ()) {
            print CC "        case $i:\n";
            for my $key (keys %$ref) {
                $prop = quote($fprops{$fieldname}->{$key});
                print CC "            if (!strcmp(propertyname,\"$key\")) return \"$prop\";\n";
            }
            print CC "            return NULL;\n";
        }
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getArraySize()
    print CC "int $msgdescclass\:\:getArraySize(void *object, int field) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getArraySize(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp = ($msgclass *)object; (void)pp;\n";
    print CC "    switch (field) {\n";
    for (my $i=0; $i<$fieldcount; $i++) {
        if ($fisarray{$fieldlist[$i]}) {
            if ($farraysize{$fieldlist[$i]} ne '') {
                print CC "        case $i: return $farraysize{$fieldlist[$i]};\n";
            } elsif ($classtype eq 'struct') {
                print CC "        case $i: return pp->$varsize{$fieldlist[$i]};\n";
            } else {
                print CC "        case $i: return pp->$getsize{$fieldlist[$i]}();\n";
            }
        }
    }
    print CC "        default: return 0;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldAsString()
    print CC "std::string $msgdescclass\:\:getFieldAsString(void *object, int field, int i) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldAsString(object,field,i);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp = ($msgclass *)object; (void)pp;\n";
    print CC "    switch (field) {\n";
    for (my $i=0; $i<$fieldcount; $i++)
    {
        if ($fkind{$fieldlist[$i]} eq 'basic') {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldlist[$i]}) {
                    if ($farraysize{$fieldlist[$i]} ne '') {
                        print CC "        case $i: if (i>=$farraysize{$fieldlist[$i]}) return \"\";\n";
                    } else {
                        print CC "        case $i: if (i>=pp->$varsize{$fieldlist[$i]}) return \"\";\n";
                    }
                    print CC "                return $tostring{$fieldlist[$i]}(pp->$var{$fieldlist[$i]}\[i\]);\n";
                } else {
                    print CC "        case $i: return $tostring{$fieldlist[$i]}(pp->$var{$fieldlist[$i]});\n";
                }
            } else {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: return $tostring{$fieldlist[$i]}(pp->$getter{$fieldlist[$i]}(i));\n";
                } else {
                    print CC "        case $i: return $tostring{$fieldlist[$i]}(pp->$getter{$fieldlist[$i]}());\n";
                }
            }
        } elsif ($fkind{$fieldlist[$i]} eq 'struct') {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: {std::stringstream out; out << pp->$var{$fieldlist[$i]}\[i\]; return out.str();}\n";
                } else {
                    print CC "        case $i: {std::stringstream out; out << pp->$var{$fieldlist[$i]}; return out.str();}\n";
                }
            } else {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: {std::stringstream out; out << pp->$getter{$fieldlist[$i]}(i); return out.str();}\n";
                } else {
                    print CC "        case $i: {std::stringstream out; out << pp->$getter{$fieldlist[$i]}(); return out.str();}\n";
                }
            }
        } else {
            die 'internal error';
        }
    }
    print CC "        default: return \"\";\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # setFieldAsString()
    print CC "bool $msgdescclass\:\:setFieldAsString(void *object, int field, int i, const char *value) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->setFieldAsString(object,field,i,value);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp = ($msgclass *)object; (void)pp;\n";
    print CC "    switch (field) {\n";
    for (my $i=0; $i<$fieldcount; $i++)
    {
        $fieldname = $fieldlist[$i];
        my $editable = propertyAsBool($fprops{$fieldname}->{editable});
        if ($editable || ($generate_setters_in_descriptor && $fkind{$fieldname} eq 'basic')) {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldname}) {
                    if ($farraysize{$fieldname} ne '') {
                        print CC "        case $i: if (i>=$farraysize{$fieldname}) return false;\n";
                    } else {
                        print CC "        case $i: if (i>=pp->$varsize{$fieldname}) return false;\n";
                    }
                    print CC "                pp->$var{$fieldname}\[i\] = $fromstring{$fieldname}(value); return true;\n";
                } else {
                    print CC "        case $i: pp->$var{$fieldname} = $fromstring{$fieldname}(value); return true;\n";
                }
            } else {
                if ($fisarray{$fieldname}) {
                    print CC "        case $i: pp->$setter{$fieldname}(i,$fromstring{$fieldname}(value)); return true;\n";
                } else {
                    print CC "        case $i: pp->$setter{$fieldname}($fromstring{$fieldname}(value)); return true;\n";
                }
            }
        }
    }
    print CC "        default: return false;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldStructName()
    print CC "const char *$msgdescclass\:\:getFieldStructName(void *object, int field) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldStructName(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    if ($fieldcount == 0) {
        print CC "    return NULL;\n";
    } else {
        print CC "    switch (field) {\n";
        for (my $i=0; $i<$fieldcount; $i++)
        {
            my $fieldname = $fieldlist[$i];
            my $opaque = propertyAsBool($fprops{$fieldname}->{opaque});  # TODO: @opaque should rather be the attribute of the field's type, not the field itself
            if ($fkind{$fieldname} eq 'struct' && !$opaque) {
                print CC "        case $i: return opp_typename(typeid($ftype{$fieldlist[$i]}));\n";
            }
        }
        print CC "        default: return NULL;\n";
        print CC "    };\n";
    }
    print CC "}\n";
    print CC "\n";

    # getFieldStructPointer()
    print CC "void *$msgdescclass\:\:getFieldStructPointer(void *object, int field, int i) const\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldStructPointer(object, field, i);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp = ($msgclass *)object; (void)pp;\n";
    print CC "    switch (field) {\n";
    for (my $i=0; $i<$fieldcount; $i++)
    {
        my $fieldname = $fieldlist[$i];
        my $opaque = propertyAsBool($fprops{$fieldname}->{opaque});  # TODO: @opaque should rather be the attribute of the field's type, not the field itself
        if ($fkind{$fieldname} eq 'struct' && !$opaque) {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldname}) {
                    $value = "pp->$var{$fieldname}\[i\]";
                } else {
                    $value = "pp->$var{$fieldname}";
                }
            } else {
                if ($fisarray{$fieldname}) {
                    $value = "pp->$getter{$fieldname}(i)";
                } else {
                    $value = "pp->$getter{$fieldname}()";
                }
            }
            $fieldclasstype = $classtype{$ftype{$fieldname}};
            $cast = "(void *)";
            $cast .= "static_cast<cObject *>" if ($fieldclasstype eq 'cobject' || $fieldclasstype eq 'cnamedobject' || $fieldclasstype eq 'cownedobject');
            if ($fispointer{$fieldname}) {
                print CC "        case $i: return $cast($value); break;\n";
            } else {
                print CC "        case $i: return $cast(\&$value); break;\n";
            }
        }
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";
}

#
# replace newlines with \n, and prefix quotes with backslash
#
sub quote($)
{
    my($text) = @_;
    $text =~ s/\\/\\\\/gs;
    $text =~ s/\n/\\n/gs;
    $text =~ s/"/\\"/g;
    return $text;
}

#
# If quoted, unquote it, otherwise return it unchanged
#
sub unquote($)
{
    my($text) = @_;
    if ($text =~ s/^"(.*)"$/$1/) {
        $text =~ s/\\"/"/gs;
        $text =~ s/\\n/\n/gs;
        $text =~ s/\\\\/\\/gs;
    }
    return $text;
}


#
# Prefixes the name with the current namespace
#
sub prefixWithNamespace($$)
{
    my($namespacename, $name) = @_;
    if ($namespacename ne '' && $name ne '') {
        # prefix it with namespace name
        $name = $namespacename . "::" . $name;
    }
    return $name;
}


#
# Plain names are always understood in the file's namespace;
# names containing "::" are understood as absolute namespace.
#
# Examples:
#
# namespace foo;
# class A;         // --> foo::A
# class ::A;       // --> ::A  (returned as A)
# class bar::A;    // --> ::bar::A (returned as bar::A)
# class ::bar::A;  // --> ::bar::A (returned as bar::A)
#
sub canonicalizeQName($$)
{
    my($namespacename, $name) = @_;
    if ($name =~ /::/) {
        # leave it, just remove reading "::"
        $name =~ s/^:://;
    }
    elsif ($namespacename ne '' && $name ne '') {
        # prefix it with namespace name
        $name = $namespacename . "::" . $name;
    }
    return $name;
}

#
# Look up the given class in @classes, allowing some flexibility with
# namespaces, and return the name from @classes. Return '' if not found.
#
sub lookupExistingClassName($$)
{
    my($namespacename, $name) = @_;
    if ($name eq '') {
        return ( $name );
    }

    #print("- lookup($name,$namespacename) among: " . join(' ', @classes) . "\n");

    # if $name contains "::" then user means explicitly qualified name; otherwise he means 'in whichever namespace it is'
    if ($name =~ /::/) {
        $name =~ s/^:://;  # remove leading "::", because names in @classes don't have it either
        return grep(/^\Q$name\E$/,@classes);
    }
    else {
        my $qname = $namespacename ? $namespacename.'::'.$name : $name; # prefer name from local namespace
        if (grep(/^\Q$qname\E$/,@classes)) {
            return $qname;
        }
        return grep(/\b\Q$name\E$/,@classes);
    }
}

#
# Like lookupExistingClassName(), but use @enums instead of @classes
#
sub lookupExistingEnumName($$)
{
    my($namespacename, $name) = @_;
    if ($name eq '') {
        return ( $name );
    }

    #print("- lookup($name,$namespacename) among: " . join(' ', @enums) . "\n");

    # if $name contains "::" then user means explicitly qualified name; otherwise he means 'in whichever namespace it is'
    if ($name =~ /::/) {
        $name =~ s/^:://;  # remove leading "::", because names in @enums don't have it either
        return grep(/^\Q$name\E$/,@enums);
    }
    else {
        my $qname = $namespacename ? $namespacename.'::'.$name : $name; # prefer name from local namespace
        if (grep(/^\Q$qname\E$/,@enums)) {
            return $qname;
        }
        return grep(/\b\Q$name\E$/,@enums);
    }
}

sub propertyAsBool($)
{
    my($propval) = @_;
    if (!defined($propval) || ($propval eq "false")) {
        return 0;  # false
    } else {
        return 1;  # true
    }
}

